// Code generated by protoc-gen-go.
// source: jingoal/dfs/proto/transfer/transfer.proto
// DO NOT EDIT!

/*
Package transfer is a generated protocol buffer package.

It is generated from these files:
	jingoal/dfs/proto/transfer/transfer.proto

It has these top-level messages:
	FileInfo
	Chunk
	ClientDescription
	NegotiateChunkSizeReq
	NegotiateChunkSizeRep
	PutFileReq
	PutFileRep
	GetFileReq
	GetFileRep
	RemoveFileReq
	RemoveFileRep
	DuplicateReq
	DuplicateRep
	ExistReq
	ExistRep
	GetByMd5Req
	GetByMd5Rep
	CopyReq
	CopyRep
*/
package transfer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// FileInfo represents file metadata.
type FileInfo struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Size   int64  `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Domain int64  `protobuf:"varint,4,opt,name=domain" json:"domain,omitempty"`
	User   int64  `protobuf:"varint,5,opt,name=user" json:"user,omitempty"`
	Md5    string `protobuf:"bytes,6,opt,name=md5" json:"md5,omitempty"`
	Biz    string `protobuf:"bytes,11,opt,name=biz" json:"biz,omitempty"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}

// Chunk represents the segment of file content.
type Chunk struct {
	Pos     int64  `protobuf:"varint,1,opt,name=pos" json:"pos,omitempty"`
	Length  int64  `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}

// ClientDescription represents the description of client.
type ClientDescription struct {
	Desc string `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
}

func (m *ClientDescription) Reset()         { *m = ClientDescription{} }
func (m *ClientDescription) String() string { return proto.CompactTextString(m) }
func (*ClientDescription) ProtoMessage()    {}

// The request message to negotiate chunk size.
type NegotiateChunkSizeReq struct {
	Size int64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
}

func (m *NegotiateChunkSizeReq) Reset()         { *m = NegotiateChunkSizeReq{} }
func (m *NegotiateChunkSizeReq) String() string { return proto.CompactTextString(m) }
func (*NegotiateChunkSizeReq) ProtoMessage()    {}

// The reply message to negotiate chunk size.
type NegotiateChunkSizeRep struct {
	Size int64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
}

func (m *NegotiateChunkSizeRep) Reset()         { *m = NegotiateChunkSizeRep{} }
func (m *NegotiateChunkSizeRep) String() string { return proto.CompactTextString(m) }
func (*NegotiateChunkSizeRep) ProtoMessage()    {}

// The request message to put file.
type PutFileReq struct {
	Info  *FileInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
	Chunk *Chunk    `protobuf:"bytes,2,opt,name=chunk" json:"chunk,omitempty"`
}

func (m *PutFileReq) Reset()         { *m = PutFileReq{} }
func (m *PutFileReq) String() string { return proto.CompactTextString(m) }
func (*PutFileReq) ProtoMessage()    {}

func (m *PutFileReq) GetInfo() *FileInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *PutFileReq) GetChunk() *Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

// The reply message to put file.
type PutFileRep struct {
	File *FileInfo `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
}

func (m *PutFileRep) Reset()         { *m = PutFileRep{} }
func (m *PutFileRep) String() string { return proto.CompactTextString(m) }
func (*PutFileRep) ProtoMessage()    {}

func (m *PutFileRep) GetFile() *FileInfo {
	if m != nil {
		return m.File
	}
	return nil
}

// The request message to get file.
type GetFileReq struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Domain int64  `protobuf:"varint,2,opt,name=domain" json:"domain,omitempty"`
}

func (m *GetFileReq) Reset()         { *m = GetFileReq{} }
func (m *GetFileReq) String() string { return proto.CompactTextString(m) }
func (*GetFileReq) ProtoMessage()    {}

// The reply message to get file.
type GetFileRep struct {
	// Types that are valid to be assigned to Result:
	//	*GetFileRep_Chunk
	//	*GetFileRep_Info
	Result isGetFileRep_Result `protobuf_oneof:"result"`
}

func (m *GetFileRep) Reset()         { *m = GetFileRep{} }
func (m *GetFileRep) String() string { return proto.CompactTextString(m) }
func (*GetFileRep) ProtoMessage()    {}

type isGetFileRep_Result interface {
	isGetFileRep_Result()
}

type GetFileRep_Chunk struct {
	Chunk *Chunk `protobuf:"bytes,1,opt,name=chunk,oneof"`
}
type GetFileRep_Info struct {
	Info *FileInfo `protobuf:"bytes,2,opt,name=info,oneof"`
}

func (*GetFileRep_Chunk) isGetFileRep_Result() {}
func (*GetFileRep_Info) isGetFileRep_Result()  {}

func (m *GetFileRep) GetResult() isGetFileRep_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GetFileRep) GetChunk() *Chunk {
	if x, ok := m.GetResult().(*GetFileRep_Chunk); ok {
		return x.Chunk
	}
	return nil
}

func (m *GetFileRep) GetInfo() *FileInfo {
	if x, ok := m.GetResult().(*GetFileRep_Info); ok {
		return x.Info
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetFileRep) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _GetFileRep_OneofMarshaler, _GetFileRep_OneofUnmarshaler, []interface{}{
		(*GetFileRep_Chunk)(nil),
		(*GetFileRep_Info)(nil),
	}
}

func _GetFileRep_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetFileRep)
	// result
	switch x := m.Result.(type) {
	case *GetFileRep_Chunk:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Chunk); err != nil {
			return err
		}
	case *GetFileRep_Info:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Info); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetFileRep.Result has unexpected type %T", x)
	}
	return nil
}

func _GetFileRep_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetFileRep)
	switch tag {
	case 1: // result.chunk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Chunk)
		err := b.DecodeMessage(msg)
		m.Result = &GetFileRep_Chunk{msg}
		return true, err
	case 2: // result.info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileInfo)
		err := b.DecodeMessage(msg)
		m.Result = &GetFileRep_Info{msg}
		return true, err
	default:
		return false, nil
	}
}

// The request message to remove file.
type RemoveFileReq struct {
	Id     string             `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Domain int64              `protobuf:"varint,2,opt,name=domain" json:"domain,omitempty"`
	Desc   *ClientDescription `protobuf:"bytes,10,opt,name=desc" json:"desc,omitempty"`
}

func (m *RemoveFileReq) Reset()         { *m = RemoveFileReq{} }
func (m *RemoveFileReq) String() string { return proto.CompactTextString(m) }
func (*RemoveFileReq) ProtoMessage()    {}

func (m *RemoveFileReq) GetDesc() *ClientDescription {
	if m != nil {
		return m.Desc
	}
	return nil
}

// The reply message to remove file.
type RemoveFileRep struct {
	Result bool `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
}

func (m *RemoveFileRep) Reset()         { *m = RemoveFileRep{} }
func (m *RemoveFileRep) String() string { return proto.CompactTextString(m) }
func (*RemoveFileRep) ProtoMessage()    {}

// The request message to duplicate file.
type DuplicateReq struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Domain int64  `protobuf:"varint,2,opt,name=domain" json:"domain,omitempty"`
}

func (m *DuplicateReq) Reset()         { *m = DuplicateReq{} }
func (m *DuplicateReq) String() string { return proto.CompactTextString(m) }
func (*DuplicateReq) ProtoMessage()    {}

// The reply message to duplicate file.
type DuplicateRep struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *DuplicateRep) Reset()         { *m = DuplicateRep{} }
func (m *DuplicateRep) String() string { return proto.CompactTextString(m) }
func (*DuplicateRep) ProtoMessage()    {}

// The request message to check existentiality of a file.
type ExistReq struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Domain int64  `protobuf:"varint,2,opt,name=domain" json:"domain,omitempty"`
}

func (m *ExistReq) Reset()         { *m = ExistReq{} }
func (m *ExistReq) String() string { return proto.CompactTextString(m) }
func (*ExistReq) ProtoMessage()    {}

// The reply message to check existentiality of a file.
type ExistRep struct {
	Result bool `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
}

func (m *ExistRep) Reset()         { *m = ExistRep{} }
func (m *ExistRep) String() string { return proto.CompactTextString(m) }
func (*ExistRep) ProtoMessage()    {}

// The request message to get a file by its md5.
type GetByMd5Req struct {
	Md5    string `protobuf:"bytes,1,opt,name=md5" json:"md5,omitempty"`
	Domain int64  `protobuf:"varint,2,opt,name=domain" json:"domain,omitempty"`
	Size   int64  `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
}

func (m *GetByMd5Req) Reset()         { *m = GetByMd5Req{} }
func (m *GetByMd5Req) String() string { return proto.CompactTextString(m) }
func (*GetByMd5Req) ProtoMessage()    {}

// The reply message to get a file by its md5.
type GetByMd5Rep struct {
	Fid string `protobuf:"bytes,1,opt,name=fid" json:"fid,omitempty"`
}

func (m *GetByMd5Rep) Reset()         { *m = GetByMd5Rep{} }
func (m *GetByMd5Rep) String() string { return proto.CompactTextString(m) }
func (*GetByMd5Rep) ProtoMessage()    {}

// The request message to copy a file.
type CopyReq struct {
	SrcFid    string `protobuf:"bytes,1,opt,name=srcFid" json:"srcFid,omitempty"`
	SrcDomain int64  `protobuf:"varint,2,opt,name=srcDomain" json:"srcDomain,omitempty"`
	DstDomain int64  `protobuf:"varint,3,opt,name=dstDomain" json:"dstDomain,omitempty"`
	DstUid    int64  `protobuf:"varint,4,opt,name=dstUid" json:"dstUid,omitempty"`
	DstBiz    string `protobuf:"bytes,5,opt,name=dstBiz" json:"dstBiz,omitempty"`
}

func (m *CopyReq) Reset()         { *m = CopyReq{} }
func (m *CopyReq) String() string { return proto.CompactTextString(m) }
func (*CopyReq) ProtoMessage()    {}

// The reply message to copy a file.
type CopyRep struct {
	Fid string `protobuf:"bytes,1,opt,name=fid" json:"fid,omitempty"`
}

func (m *CopyRep) Reset()         { *m = CopyRep{} }
func (m *CopyRep) String() string { return proto.CompactTextString(m) }
func (*CopyRep) ProtoMessage()    {}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for FileTransfer service

type FileTransferClient interface {
	// To negotiate the chunk size between client and server.
	NegotiateChunkSize(ctx context.Context, in *NegotiateChunkSizeReq, opts ...grpc.CallOption) (*NegotiateChunkSizeRep, error)
	// Put file from client to server.
	PutFile(ctx context.Context, opts ...grpc.CallOption) (FileTransfer_PutFileClient, error)
	// Get file from server to client.
	GetFile(ctx context.Context, in *GetFileReq, opts ...grpc.CallOption) (FileTransfer_GetFileClient, error)
	// Remove deletes a file.
	RemoveFile(ctx context.Context, in *RemoveFileReq, opts ...grpc.CallOption) (*RemoveFileRep, error)
	// Duplicate duplicates a file, returns a new fid.
	Duplicate(ctx context.Context, in *DuplicateReq, opts ...grpc.CallOption) (*DuplicateRep, error)
	// Exist checks existentiality of a file.
	Exist(ctx context.Context, in *ExistReq, opts ...grpc.CallOption) (*ExistRep, error)
	// GetByMd5 gets a file by its md5.
	GetByMd5(ctx context.Context, in *GetByMd5Req, opts ...grpc.CallOption) (*GetByMd5Rep, error)
	// Exist checks existentiality of a file.
	ExistByMd5(ctx context.Context, in *GetByMd5Req, opts ...grpc.CallOption) (*ExistRep, error)
	// Copy copies a file and returns its fid.
	Copy(ctx context.Context, in *CopyReq, opts ...grpc.CallOption) (*CopyRep, error)
}

type fileTransferClient struct {
	cc *grpc.ClientConn
}

func NewFileTransferClient(cc *grpc.ClientConn) FileTransferClient {
	return &fileTransferClient{cc}
}

func (c *fileTransferClient) NegotiateChunkSize(ctx context.Context, in *NegotiateChunkSizeReq, opts ...grpc.CallOption) (*NegotiateChunkSizeRep, error) {
	out := new(NegotiateChunkSizeRep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/NegotiateChunkSize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransferClient) PutFile(ctx context.Context, opts ...grpc.CallOption) (FileTransfer_PutFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileTransfer_serviceDesc.Streams[0], c.cc, "/transfer.FileTransfer/PutFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransferPutFileClient{stream}
	return x, nil
}

type FileTransfer_PutFileClient interface {
	Send(*PutFileReq) error
	CloseAndRecv() (*PutFileRep, error)
	grpc.ClientStream
}

type fileTransferPutFileClient struct {
	grpc.ClientStream
}

func (x *fileTransferPutFileClient) Send(m *PutFileReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileTransferPutFileClient) CloseAndRecv() (*PutFileRep, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutFileRep)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileTransferClient) GetFile(ctx context.Context, in *GetFileReq, opts ...grpc.CallOption) (FileTransfer_GetFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileTransfer_serviceDesc.Streams[1], c.cc, "/transfer.FileTransfer/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransferGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileTransfer_GetFileClient interface {
	Recv() (*GetFileRep, error)
	grpc.ClientStream
}

type fileTransferGetFileClient struct {
	grpc.ClientStream
}

func (x *fileTransferGetFileClient) Recv() (*GetFileRep, error) {
	m := new(GetFileRep)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileTransferClient) RemoveFile(ctx context.Context, in *RemoveFileReq, opts ...grpc.CallOption) (*RemoveFileRep, error) {
	out := new(RemoveFileRep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/RemoveFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransferClient) Duplicate(ctx context.Context, in *DuplicateReq, opts ...grpc.CallOption) (*DuplicateRep, error) {
	out := new(DuplicateRep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/Duplicate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransferClient) Exist(ctx context.Context, in *ExistReq, opts ...grpc.CallOption) (*ExistRep, error) {
	out := new(ExistRep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/Exist", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransferClient) GetByMd5(ctx context.Context, in *GetByMd5Req, opts ...grpc.CallOption) (*GetByMd5Rep, error) {
	out := new(GetByMd5Rep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/GetByMd5", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransferClient) ExistByMd5(ctx context.Context, in *GetByMd5Req, opts ...grpc.CallOption) (*ExistRep, error) {
	out := new(ExistRep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/ExistByMd5", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransferClient) Copy(ctx context.Context, in *CopyReq, opts ...grpc.CallOption) (*CopyRep, error) {
	out := new(CopyRep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/Copy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileTransfer service

type FileTransferServer interface {
	// To negotiate the chunk size between client and server.
	NegotiateChunkSize(context.Context, *NegotiateChunkSizeReq) (*NegotiateChunkSizeRep, error)
	// Put file from client to server.
	PutFile(FileTransfer_PutFileServer) error
	// Get file from server to client.
	GetFile(*GetFileReq, FileTransfer_GetFileServer) error
	// Remove deletes a file.
	RemoveFile(context.Context, *RemoveFileReq) (*RemoveFileRep, error)
	// Duplicate duplicates a file, returns a new fid.
	Duplicate(context.Context, *DuplicateReq) (*DuplicateRep, error)
	// Exist checks existentiality of a file.
	Exist(context.Context, *ExistReq) (*ExistRep, error)
	// GetByMd5 gets a file by its md5.
	GetByMd5(context.Context, *GetByMd5Req) (*GetByMd5Rep, error)
	// Exist checks existentiality of a file.
	ExistByMd5(context.Context, *GetByMd5Req) (*ExistRep, error)
	// Copy copies a file and returns its fid.
	Copy(context.Context, *CopyReq) (*CopyRep, error)
}

func RegisterFileTransferServer(s *grpc.Server, srv FileTransferServer) {
	s.RegisterService(&_FileTransfer_serviceDesc, srv)
}

func _FileTransfer_NegotiateChunkSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NegotiateChunkSizeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).NegotiateChunkSize(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileTransfer_PutFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileTransferServer).PutFile(&fileTransferPutFileServer{stream})
}

type FileTransfer_PutFileServer interface {
	SendAndClose(*PutFileRep) error
	Recv() (*PutFileReq, error)
	grpc.ServerStream
}

type fileTransferPutFileServer struct {
	grpc.ServerStream
}

func (x *fileTransferPutFileServer) SendAndClose(m *PutFileRep) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileTransferPutFileServer) Recv() (*PutFileReq, error) {
	m := new(PutFileReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileTransfer_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileTransferServer).GetFile(m, &fileTransferGetFileServer{stream})
}

type FileTransfer_GetFileServer interface {
	Send(*GetFileRep) error
	grpc.ServerStream
}

type fileTransferGetFileServer struct {
	grpc.ServerStream
}

func (x *fileTransferGetFileServer) Send(m *GetFileRep) error {
	return x.ServerStream.SendMsg(m)
}

func _FileTransfer_RemoveFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RemoveFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).RemoveFile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileTransfer_Duplicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DuplicateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).Duplicate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileTransfer_Exist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ExistReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).Exist(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileTransfer_GetByMd5_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetByMd5Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).GetByMd5(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileTransfer_ExistByMd5_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetByMd5Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).ExistByMd5(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileTransfer_Copy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CopyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).Copy(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _FileTransfer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "transfer.FileTransfer",
	HandlerType: (*FileTransferServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NegotiateChunkSize",
			Handler:    _FileTransfer_NegotiateChunkSize_Handler,
		},
		{
			MethodName: "RemoveFile",
			Handler:    _FileTransfer_RemoveFile_Handler,
		},
		{
			MethodName: "Duplicate",
			Handler:    _FileTransfer_Duplicate_Handler,
		},
		{
			MethodName: "Exist",
			Handler:    _FileTransfer_Exist_Handler,
		},
		{
			MethodName: "GetByMd5",
			Handler:    _FileTransfer_GetByMd5_Handler,
		},
		{
			MethodName: "ExistByMd5",
			Handler:    _FileTransfer_ExistByMd5_Handler,
		},
		{
			MethodName: "Copy",
			Handler:    _FileTransfer_Copy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutFile",
			Handler:       _FileTransfer_PutFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _FileTransfer_GetFile_Handler,
			ServerStreams: true,
		},
	},
}
