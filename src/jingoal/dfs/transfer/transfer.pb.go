// Code generated by protoc-gen-go.
// source: transfer.proto
// DO NOT EDIT!

/*
Package transfer is a generated protocol buffer package.

It is generated from these files:
	transfer.proto

It has these top-level messages:
	FileInfo
	Chunk
	NegotiateChunkSizeReq
	NegotiateChunkSizeRep
	PutFileReq
	PutFileRep
	GetFileReq
	GetFileRep
*/
package transfer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// FileInfo represents file metadata.
type FileInfo struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Size   int64  `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Domain int64  `protobuf:"varint,4,opt,name=domain" json:"domain,omitempty"`
	User   int64  `protobuf:"varint,5,opt,name=user" json:"user,omitempty"`
	Md5    string `protobuf:"bytes,6,opt,name=md5" json:"md5,omitempty"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}

// Chunk represents the segment of file content.
type Chunk struct {
	Pos     int64  `protobuf:"varint,1,opt,name=pos" json:"pos,omitempty"`
	Length  int64  `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}

// The request message to negotiate chunk size.
type NegotiateChunkSizeReq struct {
	Size int64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
}

func (m *NegotiateChunkSizeReq) Reset()         { *m = NegotiateChunkSizeReq{} }
func (m *NegotiateChunkSizeReq) String() string { return proto.CompactTextString(m) }
func (*NegotiateChunkSizeReq) ProtoMessage()    {}

// The reply message to negotiate chunk size.
type NegotiateChunkSizeRep struct {
	Size int64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
}

func (m *NegotiateChunkSizeRep) Reset()         { *m = NegotiateChunkSizeRep{} }
func (m *NegotiateChunkSizeRep) String() string { return proto.CompactTextString(m) }
func (*NegotiateChunkSizeRep) ProtoMessage()    {}

// The request message to put file.
type PutFileReq struct {
	Info  *FileInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
	Chunk *Chunk    `protobuf:"bytes,2,opt,name=chunk" json:"chunk,omitempty"`
}

func (m *PutFileReq) Reset()         { *m = PutFileReq{} }
func (m *PutFileReq) String() string { return proto.CompactTextString(m) }
func (*PutFileReq) ProtoMessage()    {}

func (m *PutFileReq) GetInfo() *FileInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *PutFileReq) GetChunk() *Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

// The reply message to put file.
type PutFileRep struct {
	File *FileInfo `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
}

func (m *PutFileRep) Reset()         { *m = PutFileRep{} }
func (m *PutFileRep) String() string { return proto.CompactTextString(m) }
func (*PutFileRep) ProtoMessage()    {}

func (m *PutFileRep) GetFile() *FileInfo {
	if m != nil {
		return m.File
	}
	return nil
}

// The request message to get file.
type GetFileReq struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Domain int64  `protobuf:"varint,2,opt,name=domain" json:"domain,omitempty"`
}

func (m *GetFileReq) Reset()         { *m = GetFileReq{} }
func (m *GetFileReq) String() string { return proto.CompactTextString(m) }
func (*GetFileReq) ProtoMessage()    {}

// The reply message to get file.
type GetFileRep struct {
	Chunk *Chunk `protobuf:"bytes,1,opt,name=chunk" json:"chunk,omitempty"`
}

func (m *GetFileRep) Reset()         { *m = GetFileRep{} }
func (m *GetFileRep) String() string { return proto.CompactTextString(m) }
func (*GetFileRep) ProtoMessage()    {}

func (m *GetFileRep) GetChunk() *Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for FileTransfer service

type FileTransferClient interface {
	// To negotiate the chunk size between client and server.
	NegotiateChunkSize(ctx context.Context, in *NegotiateChunkSizeReq, opts ...grpc.CallOption) (*NegotiateChunkSizeRep, error)
	// Put file from client to server.
	PutFile(ctx context.Context, opts ...grpc.CallOption) (FileTransfer_PutFileClient, error)
	// Get file from server to client.
	GetFile(ctx context.Context, in *GetFileReq, opts ...grpc.CallOption) (FileTransfer_GetFileClient, error)
}

type fileTransferClient struct {
	cc *grpc.ClientConn
}

func NewFileTransferClient(cc *grpc.ClientConn) FileTransferClient {
	return &fileTransferClient{cc}
}

func (c *fileTransferClient) NegotiateChunkSize(ctx context.Context, in *NegotiateChunkSizeReq, opts ...grpc.CallOption) (*NegotiateChunkSizeRep, error) {
	out := new(NegotiateChunkSizeRep)
	err := grpc.Invoke(ctx, "/transfer.FileTransfer/NegotiateChunkSize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransferClient) PutFile(ctx context.Context, opts ...grpc.CallOption) (FileTransfer_PutFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileTransfer_serviceDesc.Streams[0], c.cc, "/transfer.FileTransfer/PutFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransferPutFileClient{stream}
	return x, nil
}

type FileTransfer_PutFileClient interface {
	Send(*PutFileReq) error
	CloseAndRecv() (*PutFileRep, error)
	grpc.ClientStream
}

type fileTransferPutFileClient struct {
	grpc.ClientStream
}

func (x *fileTransferPutFileClient) Send(m *PutFileReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileTransferPutFileClient) CloseAndRecv() (*PutFileRep, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutFileRep)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileTransferClient) GetFile(ctx context.Context, in *GetFileReq, opts ...grpc.CallOption) (FileTransfer_GetFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileTransfer_serviceDesc.Streams[1], c.cc, "/transfer.FileTransfer/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransferGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileTransfer_GetFileClient interface {
	Recv() (*GetFileRep, error)
	grpc.ClientStream
}

type fileTransferGetFileClient struct {
	grpc.ClientStream
}

func (x *fileTransferGetFileClient) Recv() (*GetFileRep, error) {
	m := new(GetFileRep)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FileTransfer service

type FileTransferServer interface {
	// To negotiate the chunk size between client and server.
	NegotiateChunkSize(context.Context, *NegotiateChunkSizeReq) (*NegotiateChunkSizeRep, error)
	// Put file from client to server.
	PutFile(FileTransfer_PutFileServer) error
	// Get file from server to client.
	GetFile(*GetFileReq, FileTransfer_GetFileServer) error
}

func RegisterFileTransferServer(s *grpc.Server, srv FileTransferServer) {
	s.RegisterService(&_FileTransfer_serviceDesc, srv)
}

func _FileTransfer_NegotiateChunkSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NegotiateChunkSizeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(FileTransferServer).NegotiateChunkSize(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _FileTransfer_PutFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileTransferServer).PutFile(&fileTransferPutFileServer{stream})
}

type FileTransfer_PutFileServer interface {
	SendAndClose(*PutFileRep) error
	Recv() (*PutFileReq, error)
	grpc.ServerStream
}

type fileTransferPutFileServer struct {
	grpc.ServerStream
}

func (x *fileTransferPutFileServer) SendAndClose(m *PutFileRep) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileTransferPutFileServer) Recv() (*PutFileReq, error) {
	m := new(PutFileReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileTransfer_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileTransferServer).GetFile(m, &fileTransferGetFileServer{stream})
}

type FileTransfer_GetFileServer interface {
	Send(*GetFileRep) error
	grpc.ServerStream
}

type fileTransferGetFileServer struct {
	grpc.ServerStream
}

func (x *fileTransferGetFileServer) Send(m *GetFileRep) error {
	return x.ServerStream.SendMsg(m)
}

var _FileTransfer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "transfer.FileTransfer",
	HandlerType: (*FileTransferServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NegotiateChunkSize",
			Handler:    _FileTransfer_NegotiateChunkSize_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutFile",
			Handler:       _FileTransfer_PutFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _FileTransfer_GetFile_Handler,
			ServerStreams: true,
		},
	},
}
